package proxyserver;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import account.Email;
import account.POP3Account;

/**
 * Klasse zur Kommunikation mit Mailclients. Bearbeitet die Anfragen der Clients.
 * 
 * @author Fabian Reiber, Francis Opoku
 * 
 */
public class ProxyServer extends Thread {

	private Socket connection;
	private Command cObj;
	private boolean confirmed;
	private static String USER, PASS;
	private POP3Account ownAccount;
	
	/**
	 * Liste der Accounts von denen die Mails abegrufen werden sollen
	 */
	private List<POP3Account> accountList;
	
	/**
	 * 
	 * @param c Der Socket auf dem der MainServer einen Client akzeptiert hat.
	 */
	public ProxyServer(Socket c) {
		this.connection = c;
		this.cObj = new Command();
		this.confirmed = false;
		this.ownAccount = null;
		this.accountList = new ArrayList<POP3Account>();
		
		
		
		//erkennung des korrekten accounts, da user und pass ggf. identisch fuer unterschiedliche server sein kann
		//->hashcode?
		
		//wenn mails von abholaccoutn geholt werden, abfragen ob != null
		
		
	}

	/**
	 * Die Kommunikationsreihenfolge ist folgende: Solange der Socket auf dem
	 * der RequestHandler mit dem Client kommuniziert nicht geschlossen ist 1.
	 * Wartet er auf dem Socket auf eine ankommende Zeile von maximal 256
	 * Zeichen. 2. Übergibt diese der Methode handleClientRequest die die
	 * Eingabezeichenkette analysiert. 3. Löscht sich aus der Liste der von
	 * MainServer verwalteten RequestHandler.
	 */
	public void run() {
		Scanner readFromClient = null;
		PrintWriter writeToClient = null;
		while (!connection.isClosed()) {
			try {

				readFromClient = new Scanner(
						connection.getInputStream(),
						StandardCharsets.UTF_8.name());
				writeToClient = new PrintWriter(
						new OutputStreamWriter(connection.getOutputStream(),
								StandardCharsets.UTF_8), true);
				
				String clientRequest = readFromClient.findInLine(".{0,254}");
				
				handleClientRequest(clientRequest, writeToClient);
				
				
				
			} catch (Exception e) {
				try {
					connection.close();
				} catch (IOException e1) {
					System.out.println("ProxyServer: connection not closed");
				}
			}

		}

		POP3Proxy.deleteMe(this);

		try {
			if(readFromClient != null){
				readFromClient.close();
			}
			if(writeToClient != null){
				writeToClient.close();
			}
			connection.close();
		} catch (IOException e) {
			System.out
					.println("Fehler: ProxyServer.run(): connection.close");
			e.printStackTrace();
		}
	}

	/**
	 * 
	 * @param command
	 *            Eingabezeichenfolge des Clients.
	 * @param writeToClient
	 *            Der OutputStream des Sockets als PrintWriter um das Ergebnis
	 *            zum Cliet zu schreiben.
	 */
	private void handleClientRequest(String command,
			PrintWriter writeToClient) {
	
		String[] splitedCommand = command.split(" ", 2);
		String result = "";
		
		if(cObj.isValid(command)){
			//solange noch keine Authentifizierung erfolgte,
			//weiterhin nur USER und PASS moeglich
			if(!this.confirmed){
				switch(splitedCommand[0].toUpperCase()){
				case "USER":
					System.out.println("inside user");
					//ggf. user schon einzeln pruefen
					USER = splitedCommand[1];
					break;
				case "PASS":
					//ggf. pass schon einzeln pruefen
					System.out.println("inside pass");
					PASS = splitedCommand[1];
					if(!checkAccount(USER, PASS)){
						result = "-ERR couldn't find account";
					}
					break;
				default:
					result = "-ERR not authenticated yet";
					break;
				}		
			}
			else{
				//List<String> mailList = this.ownAccount.getMails();	
				List<Email> mailList = this.ownAccount.getMails();	
				switch(splitedCommand[0].toUpperCase()){
				case "STAT":
					result = doStat(mailList);
					break;
				case "LIST":
					doList(splitedCommand, mailList, writeToClient);
					break;
				case "RETR":
					break;
				case "DELE":
					break;
				case "NOOP":
					result = "+OK";
					break;
				case "RSET":
					break;
				case "UIDL":
					doUidl(splitedCommand, mailList, writeToClient);
					break;
				case "QUIT":
					doQuit();
					break;
				default:
					break;
				}	
			}
		}
		else{
			result = "-ERR not a valid command";
		}
		if(!result.isEmpty()){
			writeToClient.println(result);
		}
	}
	
	private boolean checkAccount(String user, String pass){
		this.ownAccount = new POP3Account(user, pass,
				this.connection.getInetAddress().getHostName(), 
				this.connection.getLocalPort());
		if(POP3Proxy.getKnownAccounts().contains(this.ownAccount)){
			this.confirmed = true;
			return true;
			}
		return false;
	}
	
	//private String doStat(List<String> mailList){
	private String doStat(List<Email> mailList){
		return "+OK " + mailList.size() + " " + getByteSize(mailList);
	}
	
	private void doList(String[] splitedCommand, List<Email> mailList, PrintWriter writeToClient){
		if(splitedCommand.length == 1){
			writeToClient.println("+OK " + mailList.size() + " messages ("
					+ getByteSize(mailList) + " octets)");
			for(int i = 0;i < mailList.size(); i++){
				writeToClient.println("+OK " + i + " " 
					+ mailList.get(i).getSize());
			}
		}
		else{
			int n = Integer.parseInt(splitedCommand[1]);
			if(n <= mailList.size()){
				writeToClient.println("+OK " + splitedCommand[1] + " " 
					+ mailList.get(n).getSize());
			}
			else{
				writeToClient.println("-ERR no such message, only " + mailList.size()
						+ " messages in maildrop");
			}
		}
	}
	
	
	private void doUidl(String[] splitedCommand, List<Email> mailList, PrintWriter writeToClient){
		if(splitedCommand.length == 1){
			writeToClient.println("+OK");
			for(int i = 0;i < mailList.size(); i++){
				writeToClient.println(i + " " + mailList.get(i).getUidl());
			}
		}
		else{
			int n = Integer.parseInt(splitedCommand[1]);
			if(n <= mailList.size()){
				writeToClient.println("+OK " + splitedCommand[1] + " " 
					+ mailList.get(n).getSize());
			}
			else{
				writeToClient.println("-ERR no such message, only " + mailList.size()
						+ " messages in maildrop");
			}
		}
	}
	
	
	private static int getByteSize(List<Email> mailList){
		int byteSize = 0;
		for(Email item : mailList){
			byteSize += item.getSize();
		}
		return byteSize;
	}
	
	/*
	private void doList(String[] splitedCommand, List<String> mailList, PrintWriter writeToClient){
		if(splitedCommand.length == 1){
			writeToClient.println("+OK " + mailList.size() + " messages ("
					+ getByteSizeOfMails(mailList) + " octets)");
			for(int i = 0;i < mailList.size(); i++){
				writeToClient.println("+OK " + i + " " 
					+ getByteSizeOfMail(mailList.get(i)));
			}
		}
		else{
			int n = Integer.parseInt(splitedCommand[1]);
			if(n == mailList.size()){
				writeToClient.println("+OK " + splitedCommand[1] + " " 
					+ getByteSizeOfMail(mailList.get(n)));
			}
			else{
				writeToClient.println("-ERR no such message, only " + mailList.size()
						+ " messages in maildrop");
			}
		}
	}
	
	private static int getByteSizeOfMails(List<String> list){
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream out;
		int byteSize = 0;
		try {
			out = new ObjectOutputStream(baos);
			out.writeObject(list);
			out.close();
			byteSize = baos.toByteArray().length;
			System.out.println(list.getClass().getSimpleName() +
			      " used " + byteSize + " bytes");
			} catch (IOException e) {
				e.printStackTrace();
				}
		return byteSize;
	}
	
	private static int getByteSizeOfMail(String mail){
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream out;
		int byteSize = 0;
		try {
			out = new ObjectOutputStream(baos);
			out.writeObject(mail);
			out.close();
			byteSize = baos.toByteArray().length;
			System.out.println(mail.getClass().getSimpleName() +
			      " used " + byteSize + " bytes");
			} catch (IOException e) {
				e.printStackTrace();
				}
		return byteSize;
	}
	*/
	/**
	 * Wenn MailClient die Verbindung mit "QUIT" schließen will, wird Thread geschlossen
	 */
	private void doQuit() {
		//close connection
	}

}
