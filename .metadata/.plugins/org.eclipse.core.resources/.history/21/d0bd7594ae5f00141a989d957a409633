package proxyserver;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Scanner;

import account.Email;
import account.POP3Account;

/**
 * Klasse zur Kommunikation mit Mailclients. Bearbeitet die Anfragen der Clients.
 * 
 * @author Fabian Reiber, Francis Opoku
 * 
 */
public class ProxyServer extends Thread {

	private Socket connection;
	private Command cObj;
	private boolean confirmed;
	private static String USER, PASS;
	private POP3Account ownAccount;
	
	/**
	 * Liste der Accounts von denen die Mails abegrufen werden sollen
	 * 
	 * nicht noetig, da email client sich connected, dann authentifiziert, die mails
	 * holt, diese löscht, und dann wieder disconnected. besitzt email client nun noch einen
	 * 2. pop3account, dann baut dieser wieder eine verbindung mit dem pop3_proxy auf und
	 * die prozedur faengt wieder von vorne an ---> die verbindung bleibt nicht die ganze
	 * zeit ueber bestehen, sondern wird nur zum mails holen aufgebaut.
	 */
	//private List<POP3Account> accountList;
	
	/**
	 * 
	 * @param c Der Socket auf dem der MainServer einen Client akzeptiert hat.
	 */
	public ProxyServer(Socket c) {
		this.connection = c;
		this.cObj = new Command();
		this.confirmed = false;
		this.ownAccount = null;
		//this.accountList = new ArrayList<POP3Account>();		
	}

	/**
	 * Die Kommunikationsreihenfolge ist folgende: Solange der Socket auf dem
	 * der RequestHandler mit dem Client kommuniziert nicht geschlossen ist 1.
	 * Wartet er auf dem Socket auf eine ankommende Zeile von maximal 256
	 * Zeichen. 2. Übergibt diese der Methode handleClientRequest die die
	 * Eingabezeichenkette analysiert. 3. Löscht sich aus der Liste der von
	 * MainServer verwalteten RequestHandler.
	 */
	public void run() {
		Scanner readFromClient = null;
		PrintWriter writeToClient = null;
		while (!connection.isClosed()) {
			try {
				readFromClient = new Scanner(
						connection.getInputStream(),
						StandardCharsets.UTF_8.name());
				writeToClient = new PrintWriter(
						new OutputStreamWriter(connection.getOutputStream(),
								StandardCharsets.UTF_8), true);
				String clientRequest = readFromClient.findInLine(".{0,254}");
				handleClientRequest(clientRequest, writeToClient);				
			} catch (Exception e) {
				try {
					connection.close();
				} catch (IOException e1) {
					System.out.println("couldn't close connection");
				}
			}

		}

		POP3Proxy.deleteMe(this);

		try {
			if(readFromClient != null){
				readFromClient.close();
			}
			if(writeToClient != null){
				writeToClient.close();
			}
			connection.close();
		} catch (IOException e) {
			System.out.println("couldn't close connection");
			e.printStackTrace();
		}
	}

	/**
	 * 
	 * @param command
	 *            Eingabezeichenfolge des Clients.
	 * @param writeToClient
	 *            Der OutputStream des Sockets als PrintWriter um das Ergebnis
	 *            zum Cliet zu schreiben.
	 */
	private void handleClientRequest(String command,
			PrintWriter writeToClient) {
	
		String[] splitedCommand = command.split(" ", 2);
		String result = "";
		List<Email> mailList = null;	
		
		if(cObj.isValid(command)){
			//solange noch keine Authentifizierung erfolgte,
			//weiterhin nur USER, PASS oder QUIT moeglich
			if(!this.confirmed){
				switch(splitedCommand[0].toUpperCase()){
				case "USER":
					result = doUser(splitedCommand[1]);
					break;
				case "PASS":
					doPass(splitedCommand[1], mailList, writeToClient);
					break;
				case "QUIT":
					writeToClient.println("+OK dewey POP3 server signing off (maildrop empty)");
					closeConnection();
					break;
				default:
					writeToClient.println("-ERR authentication failed");
					closeConnection();
					break;
				}		
			}
			else{
				//List<String> mailList = this.ownAccount.getMails();	
				mailList = this.ownAccount.getMails();	
				if(mailList != null){
					switch(splitedCommand[0].toUpperCase()){
					case "STAT":
						result = doStat(mailList);
						break;
					case "LIST":
						doList(splitedCommand, mailList, writeToClient);
						break;
					case "RETR":
						result = doRetr(splitedCommand[1], mailList, writeToClient);
						break;
					case "DELE":
						result = doDele(splitedCommand[1], mailList);
						break;
					case "NOOP":
						result = "+OK";
						break;
					case "RSET":
						result = doRset(mailList);
						break;
					case "UIDL":
						doUidl(splitedCommand, mailList, writeToClient);
						break;
					case "QUIT":
						String quitResult = doQuit(mailList);
						writeToClient.println(quitResult);
						try {
							this.connection.close();
						} catch (IOException e) {
							System.out.println("couldn't close connection");
							e.printStackTrace();
						}
						break;
					default:
						break;
					}	
				}
				else{
					result = "-ERR coulnd't read mails";
				}
			}
		}
		else{
			result = "-ERR not a valid command";
		}
		if(!result.isEmpty()){
			writeToClient.println(result);
		}
	}
	
	private String doUser(String splitedCommand){
		USER = splitedCommand;
		return "+OK password required for user \"" + USER + "\"";
	}
	
	private void doPass(String splitedCommand, List<Email> mailList, PrintWriter writeToClient){
		PASS = splitedCommand;
		if(!checkAccount(USER, PASS)){
			writeToClient.println("-ERR authentication failed");
			closeConnection();
		}
		else{
			mailList = this.ownAccount.getMails();
			if(mailList != null){
				String[] statResult = doStat(mailList).split(" ");
				writeToClient.println("+OK mailbox \"" + USER + "\" has " + statResult[1]
						+ " messages (" + statResult[2] + " octets)");
			}
			else{
				writeToClient.println("-ERR coulnd't read mails");
				closeConnection();
			}
		}
	}
	
	private boolean checkAccount(String user, String pass){
		this.ownAccount = new POP3Account(user, pass,
				this.connection.getInetAddress().getHostName(), 
				this.connection.getLocalPort());
		if(POP3Proxy.getKnownAccounts().contains(this.ownAccount)){
			this.confirmed = true;
			return true;
			}
		return false;
	}
	
	//private String doStat(List<String> mailList){
	private String doStat(List<Email> mailList){
		return "+OK " + mailList.size() + " " + getByteSize(mailList);
	}
	
	private void doList(String[] splitedCommand, List<Email> mailList, PrintWriter writeToClient){
		if(splitedCommand.length == 1){
			writeToClient.println("+OK " + mailList.size() + " messages ("
					+ getByteSize(mailList) + " octets)");
			for(int i = 0;i < mailList.size(); i++){
				writeToClient.println("+OK " + i + " " 
					+ mailList.get(i).getSize());
			}
		}
		else{
			int n = Integer.parseInt(splitedCommand[1]);
			if(n <= mailList.size()){
				writeToClient.println("+OK " + splitedCommand[1] + " " 
					+ mailList.get(n).getSize());
			}
			else{
				writeToClient.println("-ERR no such message, only " + mailList.size()
						+ " messages in maildrop");
			}
		}
	}
	
	private String doRetr(String splitedCommand, List<Email> mailList, PrintWriter writeToClient){
		int n = Integer.parseInt(splitedCommand);
		if(n <= mailList.size()){
			writeToClient.println("+OK " + mailList.get(n).getSize() + " octets");
			return mailList.get(n).getText();
		}
		return "-ERR no such message";
	}
	
	private String doDele(String splitedCommand, List<Email> mailList){
		int n = Integer.parseInt(splitedCommand);
		if(n <= mailList.size()){
			if(mailList.get(n).isChecked()){
				return "-ERR message " + n + " already deleted";
			}
			else{
				mailList.get(n).setChecked(true);
				return "+OK message " + n + " 1 deleted";
			}
		}
		return "-ERR no such message";
	}
	
	private String doRset(List<Email> mailList){
		int counter = 0;
		int byteSize = 0;
		for(Email item : mailList){
			if(item.isChecked()){
				item.setChecked(false);
				counter++;
				byteSize += item.getSize();
			}
		}
		return "+OK maildrop has " + counter + " messages (" + byteSize + " octets)";
	}
	
	private void doUidl(String[] splitedCommand, List<Email> mailList, PrintWriter writeToClient){
		if(splitedCommand.length == 1){
			if(mailList.size() != 0){
				writeToClient.println("+OK");
				for(int i = 0;i < mailList.size(); i++){
					writeToClient.println(i + " " + mailList.get(i).getUidl());
				}
			}
			else{
				writeToClient.println("-ERR no such message");
			}
		}
		else{
			int n = Integer.parseInt(splitedCommand[1]);
			if(n <= mailList.size() && n > 0){
				writeToClient.println("+OK " + splitedCommand[1] + " " 
					+ mailList.get(n).getUidl());
			}
			else{
				writeToClient.println("-ERR no such message, only " + mailList.size()
						+ " messages in maildrop");
			}
		}
	}
	
	/**
	 * Wenn MailClient die Verbindung mit "QUIT" schließen will, wird Thread geschlossen
	 */
	private String doQuit(List<Email> mailList) {
		int counter = mailList.size();
		for(int i = 0; i < mailList.size(); i++){
			Email mail = mailList.get(i);
			if(mail.isChecked()){
				ownAccount.removeMail(i);
				counter--;
			}
		}
		if(counter == 0){
			return "+OK dewey POP3 server signing off (maildrop empty)";
		}
		return "+OK dewey POP3 server signing off (" + counter + " messages left)";
	}
	
	private static int getByteSize(List<Email> mailList){
		int byteSize = 0;
		for(Email item : mailList){
			byteSize += item.getSize();
		}
		return byteSize;
	}
	
	private void closeConnection(){
		try {
			this.connection.close();
		} catch (IOException e) {
			System.out.println("couldn't close connection");
			e.printStackTrace();
		}
	}
	
	/*
	private void doList(String[] splitedCommand, List<String> mailList, PrintWriter writeToClient){
		if(splitedCommand.length == 1){
			writeToClient.println("+OK " + mailList.size() + " messages ("
					+ getByteSizeOfMails(mailList) + " octets)");
			for(int i = 0;i < mailList.size(); i++){
				writeToClient.println("+OK " + i + " " 
					+ getByteSizeOfMail(mailList.get(i)));
			}
		}
		else{
			int n = Integer.parseInt(splitedCommand[1]);
			if(n == mailList.size()){
				writeToClient.println("+OK " + splitedCommand[1] + " " 
					+ getByteSizeOfMail(mailList.get(n)));
			}
			else{
				writeToClient.println("-ERR no such message, only " + mailList.size()
						+ " messages in maildrop");
			}
		}
	}
	
	private static int getByteSizeOfMails(List<String> list){
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream out;
		int byteSize = 0;
		try {
			out = new ObjectOutputStream(baos);
			out.writeObject(list);
			out.close();
			byteSize = baos.toByteArray().length;
			System.out.println(list.getClass().getSimpleName() +
			      " used " + byteSize + " bytes");
			} catch (IOException e) {
				e.printStackTrace();
				}
		return byteSize;
	}
	
	private static int getByteSizeOfMail(String mail){
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream out;
		int byteSize = 0;
		try {
			out = new ObjectOutputStream(baos);
			out.writeObject(mail);
			out.close();
			byteSize = baos.toByteArray().length;
			System.out.println(mail.getClass().getSimpleName() +
			      " used " + byteSize + " bytes");
			} catch (IOException e) {
				e.printStackTrace();
				}
		return byteSize;
	}
	*/


}
